<?xml version="1.0" encoding="UTF-8"?>
<Renderer>
	<StageList>
		<!-- stage Type:[normal, specific], default value:[normal]. 
			Enable:[True,False], default value:[true] 
			Generator:[None,Mirror...]. Generator:None means none .  Mirror:Generate mirror stage when current stage render over
			-->
		<Stage Name="S1" Type="normal" Enable="True" Generator=""> 

			<Camera Name="default" /> <!-- camera name, if empty, that means it will generate by StageRoutine object. default value:[default,Homo], Homo means homogeneous coordinates, the camera's view-projection matrix is identity. -->
			<ViewPort Name="default" TopLeftX=0 TopLeftY=0 Width=-1 Height=-1 MinDepth=0 MaxDepth=1.0 /><!-- view port for the stage, format[minx, miny, width, height, mindepth, maxdepth]. default value:[0,0,-1,-1,0,1.0],-1 means use the scrren dimensions. -->
			
			<!-- Type:[backbuffer, texture], default value:[backbuffer], if type is texture, then width and height is the size
				 IsClearColor,IsClearDepth,IsClearStencil:[True,False],default True
				 Writable:[True,False], only available twhen Type is texture, if True, then the texture is writable texture, default is False
			-->
			<RenderTarget Type="backbuffer" Width="1.0" Height="1.0" IsClearColor="" IsClearDepth="" IsClearStencil="" Writable="" /> 

			<StageRoutine></StageRoutine> <!-- if specified, then the routine object will do some task on the stage. -->
			<Sort Opaque="NearToFar" Transparent="FarToNear"/> <!-- Sort algorithm for opaque and transparent object. values:[NearToFar, FarToNear] -->
			
			<!-- stage texture list
				Name : the texture name, must not null
				Type:[File, Stage, StageRenderTarget, Create]
					File : load texture file on disk, the path is in Location 
					Stage : the texture is in Stage's TextureList element, and the Location is 'StageName/TextureName'
					StageRenderTarget : texture is Stage's RenderTarget, Location is Stage Name
					Create : create a texture, use width, height, writable element
				Location:
					if Type=File, then this element is the physical path.
					if Type=Stage, then is 'StageName/TextureName'
					if Type=StageRenderTarget, it's the Stage name
					if Type=Create, then ignore it
				Width,Height,Writable : if Type=Create, they are the texture attributes
			-->
			<TextureList>
				<Texture Name="" Type="" Location="" Width="1.0" Height="1.0" Writable="" />
			</TextureList>
			
			<!--stage entity list, the entities have no parent, and draw at last.-->
			<EntityList>
				<Entity Type="Quad" VertexType="PosNormal"> <!-- type:now support[Quad, Box], VertexType:[PosColor, PosNormal, PosNormalTex] -->
					<Position x="" y="" z="" /> <!--position , in world space.-->
					<Scale x="" y="" z="" />
					<Rotation x="" y="" z="" />
					<Material>
						<Ambient r="1.0" g="1.0" b="1.0" a="1.0" />
						<Diffuse r="1.0" g="1.0" b="1.0" a="1.0" />
						<Specular r="1.0" g="1.0" b="1.0" a="1.0" />
						<Reflect r="1.0" g="1.0" b="1.0" a="1.0" />
						<!-- Stage : stage name
							 Name : the name of texture in stage's TextureList element. -->
						<DiffuseTexture Stage="" Name="" /> 
					</Material>

					<Effect Name="" ShaderType="default" Shader="" Tech="">
					</Effect> 
				</Entity>
			</EntityList>

			<!-- optional, fliter entity base on some algorithm, if not exist, a default layer will create privately.
				EntityType: the entity type for render, default is Entity
							Entity : get all visible entities from scene
							Mirror : get Mirror entities from scene
							Stage : only add the Geometries from stage's GeometryList element
							None : render nothing
				Transparent:[Yes,No], whether or not add transparent entity,default No
			-->
			<Layer EntityType="Entity" Transparent="No"> 
				<!--
					processing unit: do some spec operation
				-->
				<PU>
					<!--
						layer render state
						Type:[BuildIn,Create]. BuildIn:use the build-in render state which name is the 'Name' attribute value. Create:create new render state object.
						Name:[Solid,Wire,NoCull,CW]. 
					-->
					<RenderState Type="BuildIn" Name="">
					</RenderState>
					<!--
						Layer Blend configuration
						Enable:[True,False], 
						ColorEnable:[None,Red,Green,Blue,Alpha,All], you can use Red|Green style for bit or operation.
						AlphaConverage:[True,False]
						Src:[Zero,One,SrcColor,InvSrcColor,SrcAlpha,InvSrcAlpha,DestAlpha,InvDestAlpha,DestColor,InvDestColor,SrcAlphaSat,BlendFactor,InvBlendFactor,Src1Color,InvSrc1Color,Src1Alpha,InvSrc1Alpha]
						Oper:[Add,Sub,RevSub,Min,Max]
					-->
					<Blend Enable="" ColorEnable="" AlphaConverage="">
						<RGB Src="" Dest="" Oper="" />
						<Alpha Src="" Dest="" Oper="" />
					</Blend>
					
					<!--
						Value: integer, default is 0.
						Layer Stencil configuration
						Enable:[True,False]
						DepthBuffer-WriteMask:[Zero,All]
						Func:[Never,Less,Equal,LessEqual,Greater,NotEqual,GreaterEqual,Always]
						StencilBuffer-ReadMask:0x00-0xff
						StencilBuffer-WriteMask:0x00-0xff
						Front-Failed:[Keep,Zero,Replace,IncrSat,DecrSat,Invert,Incr,Decr]
						Front-DepthFailed,Front-Pass,Back-Failed,Back-DepthFailed,Back-Pass:same as Front-Failed
					-->
					<Stencil Value="">
						<DepthBuffer Enable="" WriteMask="" Func=""/>
						<StencilBuffer Enable="" ReadMask="" WriteMask=""/>
						<Front Failed="" DepthFailed="" Pass="" Func="" />
						<Back Failed="" DepthFailed="" Pass="" Func="" />
					</Stencil>
					
					<!-- Stage default effect name, if specified, then all entities in the stage will omit their own effect and use the default effect.default value:[empty string]. 
						Type:[default,specific],if default, then user the engine default shader, else it will load shader by it's name. 
						Shader: the name of shader, if Type=default, then it's value means the index of default shaders. 
					-->
					<Effect Name="" Type="default" Shader="" Tech=""> 
						<Param>
							<ShaderParam Name="" Type=""/> <!-- param name:the name of the parameter object, empty name is ok, just for mark. type:[Float, FloatArray, Texture] -->
							<!-- value type:[float,texture]. 
								Data:if type is float, then Data is "1.0", must float value; 
									 if type is texture, Data is the Texture Physical path; 
							-->
							<Value Type=""> 
								<Data></Data>
							</Value>
						</Param>
					</Effect> 
				</PU>
			</Layer>

			
		</Stage>
	</StageList>
</Renderer>


stage init flow
1.call StageRoutine.init to initialize the stage
2.get camera object by name
3.if render to texture, then build render target object
4.build sort object
5.build layer object
6.get effect object and build it's parameter objects

stage main flow
1.if StageRoutine exist, call StageRoutine.begin for update
2.recv entity list which for render
3.add entity to layer
4.for every layer, sort it's entity
5.compute camera property
6.if effect exist, binding effect, set effect parameter and camera parameter
7.set view port
8.binding render target
9.for every layer, create opaque entity draw batch, add batch to pipeline
10.for every layer, create transparent entity draw batch, add batch to pipeline
11.call StageRoutine.end

PS:stage can nest, the child stage can use parent's property if it's not have it, and for every frame, parent will draw nothing, only child stage perform the draw call.

batch structure
{
	effect
	entity
}

pipeline
{
	batch_list
}

