<?xml version="1.0" encoding="UTF-8"?>
<Renderer>
	<StageList>
		<!-- stage Type:[normal, specific], default value:[normal]. Enable:[True,False], default value:[true] -->
		<Stage Name="S1" Type="normal" Enable="True"> 

			<RenderState Type="Default">
			</RenderState>

			<Camera Name="default" /> <!-- camera name, if empty, that means it will generate by StageRoutine object. default value:[default,Homo], Homo means homogeneous coordinates, the camera's view-projection matrix is identity. -->
			<ViewPort Name="default" TopLeftX=0 TopLeftY=0 Width=-1 Height=-1 MinDepth=0 MaxDepth=1.0 /><!-- view port for the stage, format[minx, miny, width, height, mindepth, maxdepth]. default value:[0,0,-1,-1,0,1.0],-1 means use the scrren dimensions. -->
			
			<!-- Type:[backbuffer, texture], default value:[backbuffer], if type is texture, then width and height is the size
				 IsClearColor,IsClearDepth,IsClearStencil:[True,False],default True
			-->
			<RenderTarget Type="backbuffer" Width=1.0 Height=1.0 IsClearColor="" IsClearDepth="" IsClearStencil="" /> 

			<StageRoutine></StageRoutine> <!-- if specified, then the routine object will do some task on the stage. -->
			<Sort Opaque="NearToFar" Transparent="FarToNear"/> <!-- Sort algorithm for opaque and transparent object. values:[NearToFar, FarToNear] -->
			
			<!--stage entity list, the entities have no parent, and draw at last.-->
			<EntityList>
				<Entity Type="Quad" VertexType="PosNormal"> <!-- type:now support[Quad, Box], VertexType:[PosColor, PosNormal, PosNormalTex] -->
					<Position x="" y="" z="" /> <!--position , in world space.-->
					<Scale x="" y="" z="" />
					<Rotation x="" y="" z="" />
					<Material>
						<Ambient r="1.0" g="1.0" b="1.0" a="1.0" />
						<Diffuse r="1.0" g="1.0" b="1.0" a="1.0" />
						<Specular r="1.0" g="1.0" b="1.0" a="1.0" />
						<Reflect r="1.0" g="1.0" b="1.0" a="1.0" />
						<DiffuseTexture Type="[Local,Stage]" File="" /> <!-- if Type=Local, then file is the texture file path, if Type=Stage, then File is the Stage's RenderTarget which is Texture. -->
					</Material>

					<Effect Name="" ShaderType="default" Shader="" Tech="">
					</Effect> 
				</Entity>
			</EntityList>

			<!-- optional, fliter entity base on some algorithm, if not exist, a default layer will create privately.
				EntityType: the entity type for render, default is Entity
							Entity : get all visible entities from scene
							Mirror : get Mirror entities from scene
							Stage : only add the Geometries from stage's GeometryList element
				Transparent:[Yes,No], whether or not add transparent entity,default No
			-->
			<Layer EntityType="Entity" Transparent="No"> 
				<!--
					Layer Blend configuration
					Src:[Zero,One,SrcColor,InvSrcColor,SrcAlpha,InvSrcAlpha,DestAlpha,InvDestAlpha,DestColor,InvDestColor,SrcAlphaSat,BlendFactor,InvBlendFactor,Src1Color,InvSrc1Color,Src1Alpha,InvSrc1Alpha]
					Oper:[Add,Sub,RevSub,Min,Max]
				-->
				<Blend>
					<RGB Src="" Dest="" Oper="" />
					<Alpha Src="" Dest="" Oper="" />
				</Blend>
				
				<!--
					Layer Stencil configuration
					Enable:[True,False]
					DepthBuffer-WriteMask:[Zero,All]
					Func:[Never,Less,Equal,LessEqual,Greater,NotEqual,GreaterEqual,Always]
					StencilBuffer-ReadMask:0x00-0xff
					StencilBuffer-WriteMask:0x00-0xff
					Front-Failed:[Keep,Zero,Replace,IncrSat,DecrSat,Invert,Incr,Decr]
					Front-DepthFailed,Front-Pass,Back-Failed,Back-DepthFailed,Back-Pass:same as Front-Failed
				-->
				<Stencil>
					<DepthBuffer Enable="" WriteMask="" Func=""/>
					<StencilBuffer Enable="" ReadMask="" WriteMask=""/>
					<Front Failed="" DepthFailed="" Pass="" Func="" />
					<Back Failed="" DepthFailed="" Pass="" Func="" />
				</Stencil>
			</Layer>

			<Effect Name="" Type="default" Shader="" Tech=""> <!-- Stage default effect name, if specified, then all entities in the stage will omit their own effect and use the default effect.default value:[empty string]. Type:[default,specific],if default, then user the engine default shader, else it will load shader by it's name. Shader: the name of shader, if Type=default, then it's value means the index of default shaders. -->
				<Param>
					<ShaderParam Name="" Type=""/> <!-- param name:the name of the parameter object, empty name is ok, just for mark. type:[Float, FloatArray, Texture] -->
					<Value Type=""> <!-- value type:[Raw,PhysicalPath,ConfPath]. Data:if type is Raw, then Data is "1.0,2.0,3.0", must float value; if type is PhysicalPath, Data is the Texture Physical path(test.png); if type is ConfPath, Data is the stage name, then will binding the stage's render target as a texture to the parameter. -->
						<Data></Data>
					</Value>
				</Param>
			</Effect> 
		</Stage>
	</StageList>
</Renderer>


stage init flow
1.call StageRoutine.init to initialize the stage
2.get camera object by name
3.if render to texture, then build render target object
4.build sort object
5.build layer object
6.get effect object and build it's parameter objects

stage main flow
1.if StageRoutine exist, call StageRoutine.begin for update
2.recv entity list which for render
3.add entity to layer
4.for every layer, sort it's entity
5.compute camera property
6.if effect exist, binding effect, set effect parameter and camera parameter
7.set view port
8.binding render target
9.for every layer, create opaque entity draw batch, add batch to pipeline
10.for every layer, create transparent entity draw batch, add batch to pipeline
11.call StageRoutine.end

PS:stage can nest, the child stage can use parent's property if it's not have it, and for every frame, parent will draw nothing, only child stage perform the draw call.

batch structure
{
	effect
	entity
}

pipeline
{
	batch_list
}

