<?xml version="1.0" encoding="UTF-8"?>
<Renderer>
	<!-- view port for the stage, format[minx, miny, width, height, mindepth, maxdepth]. default value:[0.0,0.0,0.0,1.0,0.0,1.0],-1 means use the scrren dimensions. -->
	<ViewPort TopLeftX="0.0" TopLeftY="0.0" Width="1.0" Height="1.0" MinDepth="0.0" MaxDepth="1.0" />
	<Camera Name="Default" />
	<StageList>
		<!-- stage Type:[Normal, Sprite, Primitive, ...], default value:normal, if others, the parser will create specific stage
												Normal:normal stage
												Sprite:render 2d sprite, all child nodes information in stage will skip
												Primitive:render frame primitive
			Enable:[True,False], default value:[true]
			Generator:[None,Mirror...]. Generator:None means none .  Mirror:Generate mirror stage when current stage render over
			-->
		<Stage Name="S1" Type="Normal" Enable="True" Generator="">

			<Camera Name="Default" /> <!-- camera name default value:[Default,Homo], Homo means homogeneous coordinates, the camera's view-projection matrix is identity. -->

			<!-- Type:[backbuffer, texture], default value:[backbuffer], if type is texture, then width and height is the size
				 IsClearColor,IsClearDepth,IsClearStencil:[True,False],default True
				 Writable:[True,False], only available twhen Type is texture, if True, then the texture is writable texture, default is False
			-->
			<RenderTarget Type="backbuffer" Width="1.0" Height="1.0" IsClearColor="" IsClearDepth="" IsClearStencil="" Writable="" />

			<!-- stage texture list
				Name : the texture name, must not null
				Type:[File, Stage, StageRenderTarget, Create]
					File : load texture file on disk, the path is in Location
					Files : load textures from file list
					Stage : the texture is in Stage's TextureList element, and the Location is 'StageName/TextureName'
					StageRenderTarget : texture is Stage's RenderTarget, Location is Stage Name
					Create : create a texture, use width, height, writable element
				Location:
					if Type=File, then this element is the physical path.
					if Type=Files, Location=[path;path]
					if Type=Stage, then is 'StageName/TextureName'
					if Type=StageRenderTarget, it's the Stage name
					if Type=Create, then ignore it
				Width,Height,Writable : if Type=Create, they are the texture attributes
			-->
			<TextureList>
				<Texture Name="" Type="" Location="" Width="1.0" Height="1.0" Writable="" />
			</TextureList>

			<!--stage entity list, the entities have no parent, and draw at last.-->
			<EntityList>
				<!--
					Type:now support[Quad, Box, None], if Type=None, then nothing will render
					VertexType:[PosColor, PosNormal, PosNormalTex] -->
				<Entity Type="Quad" VertexType="PosNormal">
					<Position x="" y="" z="" /> <!--position , in world space.-->
					<Scale x="" y="" z="" />
					<Rotation x="" y="" z="" />
					<Material>
						<Ambient r="1.0" g="1.0" b="1.0" a="1.0" />
						<Diffuse r="1.0" g="1.0" b="1.0" a="1.0" />
						<Specular r="1.0" g="1.0" b="1.0" a="1.0" />
						<Reflect r="1.0" g="1.0" b="1.0" a="1.0" />
						<!-- Stage : stage name
							 Name : the name of texture in stage's TextureList element. -->
						<DiffuseTexture Stage="" Name="" />
					</Material>

					<Effect Name="" ShaderType="default" Shader="" Tech="">
					</Effect>
				</Entity>
			</EntityList>

			<!-- optional, fliter entity base on some algorithm, if not exist, a default layer will create privately.
				EntityType: the entity type for render, default is Entity
							Entity : get all visible entities from scene
							Mirror : get Mirror entities from scene
							Stage : only add the Geometries from stage's GeometryList element
							None : render nothing
				Transparent:[Yes,No], whether or not add transparent entity,default No
			-->
			<Layer Name="" EntityType="Entity" Transparent="No">
				<!--
					processing unit: do some spec operation
				-->
				<PU>
					<!--
						layer render state
						Type:[BuildIn,Create]. BuildIn:use the build-in render state which name is the 'Name' attribute value. Create:create new render state object.
						Name:[Solid,Wire,NoCull,CW].
					-->
					<RenderState Type="BuildIn" Name="">
					</RenderState>
					<!--
						Layer Blend configuration
						Enable:[True,False],
						ColorEnable:[None,Red,Green,Blue,Alpha,All], you can use Red|Green style for bit or operation.
						AlphaConverage:[True,False]
						Src:[Zero,One,SrcColor,InvSrcColor,SrcAlpha,InvSrcAlpha,DestAlpha,InvDestAlpha,DestColor,InvDestColor,SrcAlphaSat,BlendFactor,InvBlendFactor,Src1Color,InvSrc1Color,Src1Alpha,InvSrc1Alpha]
						Oper:[Add,Sub,RevSub,Min,Max]
					-->
					<Blend Enable="" ColorEnable="" AlphaConverage="">
						<RGB Src="" Dest="" Oper="" />
						<Alpha Src="" Dest="" Oper="" />
					</Blend>

					<!--
						Value: integer, default is 0.
						Layer Stencil configuration
						Enable:[True,False]
						DepthBuffer-WriteMask:[Zero,All]
						Func:[Never,Less,Equal,LessEqual,Greater,NotEqual,GreaterEqual,Always]
						StencilBuffer-ReadMask:0x00-0xff
						StencilBuffer-WriteMask:0x00-0xff
						Front-Failed:[Keep,Zero,Replace,IncrSat,DecrSat,Invert,Incr,Decr]
						Front-DepthFailed,Front-Pass,Back-Failed,Back-DepthFailed,Back-Pass:same as Front-Failed
					-->
					<Stencil Value="">
						<DepthBuffer Enable="" WriteMask="" Func=""/>
						<StencilBuffer Enable="" ReadMask="" WriteMask=""/>
						<Front Failed="" DepthFailed="" Pass="" Func="" />
						<Back Failed="" DepthFailed="" Pass="" Func="" />
					</Stencil>

					<!-- Stage Layer effect, if specified, then all entities in the stage Layer will
						 omit their own effect and use the default effect.
						 Type : [Normal, GP], Normal effect and GP effect, GP for GPGPU
					-->
					<Effect Name="" Type="">
						<!-- for GPGPU config, thread count -->
						<GP GroupX="" GroupY="" GroupZ="" />
						<!-- shader config
							Type : [default,specific],if default, then user the engine default shader, else it will load shader by it's name.
							Shader : the name of shader, if Type=default, then it's value means the index of default shaders.
						-->
						<Shader Type="" Name="" Tech="" />
						<!-- param name:the name of the parameter in shader.
							 type:[Float, FloatArray, Texture, Matrix]
							 Writable : [True,False]
						-->
						<Param Name="" Type="" Writable=""/>
							<!-- Data
									if Type is Float, then Data is float value
									if Type is FloatArray, then Data is float values with separator ';'.
									if type is Texture, Data is the texture's name in stage's TextureList element, with the 'StageName/TextureName' style.
									if type is Matrix,then Data is float values with separator ';', 4x4 matrix.
							-->
							<Data></Data>
						</Param>
					</Effect>
				</PU>
			</Layer>


		</Stage>
	</StageList>
</Renderer>


stage init flow
1.call StageRoutine.init to initialize the stage
2.get camera object by name
3.if render to texture, then build render target object
4.build sort object
5.build layer object
6.get effect object and build it's parameter objects

stage main flow
1.if StageRoutine exist, call StageRoutine.begin for update
2.recv entity list which for render
3.add entity to layer
4.for every layer, sort it's entity
5.compute camera property
6.if effect exist, binding effect, set effect parameter and camera parameter
7.set view port
8.binding render target
9.for every layer, create opaque entity draw batch, add batch to pipeline
10.for every layer, create transparent entity draw batch, add batch to pipeline
11.call StageRoutine.end

PS:stage can nest, the child stage can use parent's property if it's not have it, and for every frame, parent will draw nothing, only child stage perform the draw call.

batch structure
{
	effect
	entity
}

pipeline
{
	batch_list
}

